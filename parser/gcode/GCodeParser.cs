using System;
using System.IO;
using System.Text;

namespace SlicerMeta.parser.gcode
{
    // AIO GCode Parser
    // Currently supports Orca-FlashForge & FlashPrint g-code files
    public class GCodeParser
    {
        public SlicerMeta SlicerInfo { get; private set; }
        public SlicerFileMeta FileInfo { get; private set; }

        public GCodeParser()
        {
            SetDefaults();
        }

        private void SetDefaults()
        {
            SlicerInfo = null;
            FileInfo = null;
        }

        public GCodeParser Parse(string filePath)
        {
            if (!IsOkExt(filePath)) throw new ArgumentException("Cannot process provided file, invalid extension");
            var slicerType = GetSlicerType(filePath);
            switch (slicerType)
            { // automatically detect the slicer from the first line , pass processing onto the respective class
                default:
                case SlicerType.Unknown:
                    throw new ArgumentException("Cannot process file, sliced by unknown software");
                case SlicerType.FlashPrint:
                    var result = FlashPrintParser.Parse(filePath);
                    SlicerInfo = result.Item1;
                    FileInfo = result.Item2;
                    break;
                case SlicerType.OrcaFF:
                    var result2 = OrcaFlashForgeParser.Parse(filePath);
                    SlicerInfo = result2.Item1;
                    FileInfo = result2.Item2;
                    break;
            }
            return this;
        }

        public GCodeParser ParseFromStream(Stream stream)
        {
            var slicerType = GetSlicerTypeFromStream(stream);
            switch (slicerType)
            { // automatically detect the slicer from the first line , pass processing onto the respective class
                default:
                case SlicerType.Unknown:
                    throw new ArgumentException("Cannot process file, sliced by unknown software");
                case SlicerType.FlashPrint:
                    var result = FlashPrintParser.Parse(stream);
                    SlicerInfo = result.Item1;
                    FileInfo = result.Item2;
                    break;
                case SlicerType.OrcaFF:
                    var result2 = OrcaFlashForgeParser.Parse(stream);
                    SlicerInfo = result2.Item1;
                    FileInfo = result2.Item2;
                    break;
            }
            return this;
        }

        private bool IsOkExt(string filePath)
        {
            if (filePath.EndsWith(".g") || filePath.EndsWith(".gcode")) return true; // gcode formats
            if (filePath.EndsWith(".3mf")) return true; // 3mf (newer) format
            return false;
        }
        
        private SlicerType GetSlicerType(string filePath)
        { // read from local file
            using (var reader = new StreamReader(filePath))
            {
                var header = reader.ReadLine();
                if (header == null) return SlicerType.Unknown;
                if (header.StartsWith(";generated by ffslicer")) return SlicerType.FlashPrint;
                return header.StartsWith("; THUMBNAIL") ? SlicerType.OrcaFF : SlicerType.Unknown;
            }
        }

        private SlicerType GetSlicerTypeFromStream(Stream stream)
        { // read from file in memory
            using (var reader = new StreamReader(stream, Encoding.Default, detectEncodingFromByteOrderMarks: true, bufferSize: 1024, leaveOpen: true))
            {
                var header = reader.ReadLine();
                if (header == null) return SlicerType.Unknown;
                if (header.StartsWith(";generated by ffslicer")) return SlicerType.FlashPrint;
                return header.StartsWith("; THUMBNAIL") ? SlicerType.OrcaFF : SlicerType.Unknown;
            }
        }
    }
}